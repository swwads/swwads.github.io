

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=44218032" charset="UTF-8"></script>
  <script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?7192fa361f5cabb11d8a22de41c1ba8f";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>
  
  <title>JS动画笔记 | ZY</title>
  <meta name="author" content="Yi Zhou">
  
  <meta name="description" content="特效的笔记
放大镜的笔记,原件在开始做特效的js特效里面,下面有东西可以研究
里面有很多逗号的写法,反正声明都是逗号,一部分语句也是逗号,这一部分都是操作同一个元素的时候,就是逗号,但是如果是新的元素,就会用新的声明,然后使用分号来断语句; 
g = (c.width(), c.height(), ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JS动画笔记"/>
  <meta property="og:site_name" content="ZY"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/imgs/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="ZY" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
</head>


<body>
  <header><div>
		
			<div id="imglogo">
				<a href="/"><img src="/imgs/logo.png" alt="ZY" title="ZY"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name">ZY</h1>
				<h2 class="blog-motto">my Bolg</h2>
			</div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li> <a href="/atom.xml">RSS</a> </li>
				</ul>
			</nav>			
</div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header class="article-info clearfix">
  <h1 itemprop="name">
	JS动画笔记
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="Yi Zhou">Yi Zhou</a>
    </p>
  <p class="article-time">
    <time datetime="2018-01-18T12:38:10.000Z" itemprop="datePublished">2018-01-18</time>
    Update date:<time datetime="2018-01-18T12:38:35.041Z" itemprop="dateModified">2018-01-18</time>
    
  </p>
</header>
    <div class="entry">
		
        <p>特效的笔记</p>
<p>放大镜的笔记,原件在开始做特效的js特效里面,下面有东西可以研究</p>
<p>里面有很多逗号的写法,反正声明都是逗号,一部分语句也是逗号,这一部分都是操作同一个元素的时候,就是逗号,但是如果是新的元素,就会用新的声明,然后使用分号来断语句; </p>
<p>g = (c.width(), c.height(), new Image); //这个写法有点意思, </p>
<pre><code>原理如下:
    //把当参数的图片对象复制一份,长和款以及图片源和原标签一样,新建图片对象 new Image

    //新建一个json对象,里面包含放大镜的所有属性
    //让原图片去掉拖拽的默认时间,就是让图片透明度降低并可以移动的效果
    //新建一个盒子,来放放大镜,先设置其id,则直接放在body里面,设置绝对定位,再用$将其变成jq对象,再给其初始化样式
    // &quot;pointer-events&quot;: &quot;none&quot;,visibility: &quot;hidden&quot;,这两个都是细节,宽高背景定位什么的肯定是必须的了,
    //在原图片上移动的时候,开始动态设置放大镜盒子的位置
jq元素的offset()方法包含两个属性,再.然后left或者top.
</code></pre><p>判断鼠标进入方向来移动遮罩</p>
<p>原件在开始做效果的,js特效里面</p>
<p>offset只有top和left,这里用top+本身的高度,等于bottom,就是底边离顶部的位置 </p>
<p>里面涉及了stop()方法的运用 </p>
<pre><code>它用了一个move函数,这个函数判断鼠标进入和退出的两个事件,用一个bool值来判断,从哪边进去,哪边出来都有判断,
    //先判断这个被进入的盒子的offset,四个位置,然后用pageX,和pageY减去这几个,得出和边的相对位置,然后取绝对值,再用一个数字来接收这个绝对值的最小值,
    //进入盒子或者出去盒子的时候,判断这个最小值是和鼠标的四个位置中的哪一个相等,
    //每一个值都两个事件,进入或者出来,进来的时候先设置遮罩在边的边上,比如从上面进入,就设置遮罩在top:-230px,然后用animate走到top:0这个位置来.其他位置也一样
      //总之,用一个函数判断进来和出去的位置,然后用bool值做参数判断,很妙,感觉.
</code></pre><p>留言板的效果</p>
<pre><code>创建容器,设定随机获得的颜色数组,设定一个生成函数,函数内容是获得随机颜色,生成带text的方块,放进容器,调用一个拖拽方法.
//这个判断的旗子其实没必要,只要放在另外一个函数里面就好了
//$this.width() + parseInt($this.css(&apos;padding-left&apos;), 10) + parseInt($this.css(&apos;padding-right&apos;), 10)
//上面这个方法,就是获得了包括padding的宽度,如果不加上的话就只有之前内容宽度的数值
拖拽方法:
    //先初始化, 获取自己,获取父元素,获取自己和父元素的宽和高,根据相应的宽和高设置一个随机数,生成的时候只会生成在父盒子里面,声明了全局的变量(鼠标在页面的坐标,元素再父元素里的定位位置)设置了一个标记,isDown,代表有没有按上纸条,通过mousedown和mouseup,来切换.
    //按上去的时候,先让被按的图片z-INdex提高,兄弟的Z-index变小;同时,获取鼠标在页面的位置,和被按的纸条在父元素的偏移位置.然后取消了默认拖拽事件
    //移动的时候,用移动的位置减去全局的那个变量,再加上全局的positionX,又给赋值给moveX;
    //然后判断移动时候left和top值,如果超出了就手动赋值在父盒子里面,
函数完成后的初始调用
    //给父盒子里面所有的a标签上设置关闭事件,直接移除整个元素,用remove;
    //设定初始数组,全部调用生成方法
    //给输入框,设定keydown事件,只要键盘值是13,就是按了回车键,然后将input的value值传入生成函数,然后把input的值设为空, 
    整体的流程伪代码就是如此
</code></pre><p>移动动画的时候,倒序移动的时候为什么非常慢?</p>
<p>因为margin的问题,或者说offsetleft和left在里面是不一样的,由于margin的存在,里面style.left和元素的offsetleft是不一样的,每次计算offsetleft的时候都是left加上margin, 所以解决方法有两个</p>
<pre><code>要么把margin改成0;要么在赋值的时候手动算上margin的值
</code></pre><p>排他思想是什么?</p>
<p>就是在设定某一个队列里面特定一个元素的属性或样式的时候,先把所有元素的属性或样式全部清零,再将需要设置的元素单独设置上.</p>
<p>一般应用在图片转换等情况上面 </p>
<p>拖拽特效如何形成?</p>
<pre><code>// 当鼠标按下的时候，求鼠标在盒子中的位置  ,
// 鼠标在盒子中的位置 = 鼠标在页面上的位置 - 盒子的位置,
用这个位置来作为移动的时候,盒子定位的参考
// 当鼠标在页面上移动的时候。求盒子的坐标
// 盒子的坐标 = 鼠标当前在页面中的位置 - 鼠标在盒子中的位置
</code></pre><p>弹出层特效图如何做?</p>
<p>设置一个遮盖层和需要弹出的东西.</p>
<p>遮盖层用来阻挡其他的元素,让用户关注弹出的元素,执行特定的操作.</p>
<p>弹出的东西就是display:none 和 block 区别.</p>
<p>放大镜的思路?</p>
<p>里面会包括以下几个元素:</p>
<p>1.放小图片的盒子  2.小盒子 3.小盒子里面的测定范围的盒子,或说是mask 4.大盒子 5.大盒子里面的图片</p>
<p>按一下步骤实现</p>
<ol>
<li>获取鼠标的位置,  </li>
<li>mask的中心是鼠标的位置 </li>
<li>限定mask的移动范围,限定在盒子里面</li>
<li>根据mask的可移动范围和大图片的可移动范围来设定比例,</li>
<li>根据比例同步大图片的移动</li>
</ol>
<p>模拟滚动条的思路?</p>
<pre><code>//1 根据内容的大小，计算滚动条的高度
//  滚动条的高度 / scroll的高度 = box的高度 / 内容的高度
// 当内容的高度大于box的高度，再计算 滚动条的高度，否则的话滚动条的高度为0
//2 让滚动条能够拖拽
 2.1 当鼠标按下的时候，求鼠标在滚动条中的位置
//3 当拖拽滚动条的时候，改变内容的位置
// 内容滚动的距离 / 内容最大能够滚动的距离 = 滚动条滚动的距离 / 滚动条最大能够滚动的距离
</code></pre><p>动画移动的思路?</p>
<pre><code>用定时器,每隔多少毫秒产生一次移动事件
//会定时器的方法:包括设定和清除定时器;判断页面存在的定时器,则清除多余的定时器
//设置,每一步的长度:step ,设置目标位置 target,获取现在位置 current
//如果要目标位置大于现在位置,则step为正;如果相反,则step为负: step= -Math.abs(step);
//当元素和目标的位置小于一步的长度时,并退出

//判断定时器数量,并清除多余的定时器
if (element.timerId) {
            clearInterval(element.timerId);  //源代码里面把定时器当成了element的一个方法,
            timerId = null;  //这个方法被设定为空
        }  //
//移动盒子是这两个代码
  current += step;  //现在的数字加上step
    element.style.left = current + &apos;px&apos;; //元素的样式注意加上px;
</code></pre><p>轮播图的思路?</p>
<p>要准备的东西如下</p>
<pre><code>一个滚动屏幕,里面上面是几个ul&gt;li&gt;img,下面是一个有序的ol,根据图片数量生成li,里面的内容是序号.
下面有两个箭头的方块,箭头是固定定位的.
</code></pre><p>要会的东西如下</p>
<pre><code>动态生成序号
//要会获取元素,会document.createElenment,生成的li,再ol.appendchild.再innertext.
点击序号 动画的方式 切换图片
//设置序号的点击事件,实现当前序号高亮,以及动画改变图片位置 //序号高亮是用类样式,排他思想实现当前元素高亮,
//用li.setAttribute(&apos;index&apos;, i);来设置li的自己的属性下标.再用这个下标来得出对应的大图片需要走多少距离.第二个目标是个目标距离的参数,之前的动画函数,也只是需要目标参数,会自动判断当前位置和目标位置的距离,来实现左移右移.
鼠标放到盒子上显示箭头
//显示和消失箭头就是display就好了.
//用的是不会冒泡的onmouseenter和onmouseleave
//放进去的时候取消定时器滚动,出来的时候又重新设置一次.
 实现上一张和下一张的功能
 //可以直接设置成动画的实现形式,每点击一次 ,则需要移动的位置多增加一个下标,就是加1
 //还可以用 ol.children[index].click(). 这个.click()等于是模拟人工手动点击一下
 //点击事件具体是:先下标加1 ,然后ol里面的对应下标的li,被点击一次.
//如果是最后一张图片，不让index++
 会出现一个bug
 //因为下一张的办法是利用下标++,然后模拟点击ol里面的li来做的,那么,平时不点击箭头的时候,那下标会一直为0,而当你用数字下标来点击之后,会实现图片的滚动,但如果这时候点击箭头,那么下标会总是为2.就是说,这个bug在于不管之前图片在哪里,第一次点击箭头,总是模拟点击一下数字2.
 //解决方法是:让箭头获取的下标和点击数字时获取的下标是一致的,就是说,点击数字也会改变箭头函数里面已经存在的下标.
 解决bug之后再继续,要实现无缝滚动就在边缘张数来设置事件,如下:
 //实现无缝滚动就要增加一个克隆第一张图片放到图片后面,
 //当然要实现第一张或最后一张的操作,就把图片定位到特定的位置,设置动画来移动
 右箭头(下一张)的效果
 // 判断索引是否小于等于5,小于等于5则正常运行,到了最后一张,再点击的话,用了一个if..else ,
 //else {
   //以动画的形式移动到克隆的图片的后面去,
 //将ol里面的li都取消高亮,然后让第一序号的高亮显示出来.
//还要注意一点,下标格子已经高亮,然后真正的下标要设定为0;同时,ul的宽度,就是他的位置放到最前面来,设置style.left=&apos;0px&apos;;
 //当最后一张,再移动的话,移动到的话是移动到克隆图片,强行数字1高亮,然后下标变成0.
 //再点击右箭头,那先将图片变成真正的第一张图片,再进行动画滑动
 左箭头(上一张)效果
//就是处理当下标为0时,就是第一章图片然后向左时,这个时候,
//点击之后,让图片的位置定位到那张被克隆的最后一张图片上面,然后把下标设置为chiren.length就是最后一张.
 //index--之后然后再模拟一个点击第五张图片的效果.
 自动播放
 //定时器,定时按点击一下右箭头.
  var timerId = setInterval(function () {
    arrRight.click();
  }, 2000);
//像这个就是两秒移动一次
</code></pre><p>这里要注意一下的东西</p>
<pre><code>创建元素一定要创建对,也要找到元素;
动态创建的小按钮,设置的下标属性非常重要,这个下标贯穿整个程序,都是根据下标来获得该移动的位置;具体来讲,代码本来的操作是根据一个    全局的index  来设置移动的位置,如果不让index和图片下标同步,那箭头的移动效果和鼠标点击的效果会脱节.视频中bug产生的原因.
同时,全局变量index下标的变化以及图片位置的变化一定要同步起来,这个是关键.
不只是点了5之后,再点右箭头会出现在第2个,因为是脱节的,所以之前是任何图片,下一次点击箭头都是2;
克隆元素的作用在于让代码函数化
轮播便是图片的移动,只是移动到一定位置后,比如最初或者最后一个,再强行设定移动的位置,只是克隆图片和第一个图片是一样的,所以那一瞬间的移动是看不出来.
最后一张图片的处理是,强行把下标变成0,然后强行让数字1高亮,然后显示克隆的图片,
鼠标放到盒子上出现箭头并取消定时器,离开盒子并开启定时器,这个事情必须让定时器的名字一致,不然的话会出现多个定时器,就出现过一次这样的bug.
</code></pre><p>贪蛇吃案例</p>
<p>随机产生方块案例</p>
<p>根据案例看看</p>
<p>总体而言 先分离出对象,看哪些东西是固定的,哪些东西是要变动的.比如在这里,盒子的样式什么可以固定,而他们的位置是要变动,固定的用属性,变动的用方法 </p>
<p>有大概东西: 父盒子,包括它的样式,子盒子,包括它的样式(父盒子样式也可以用Js重新写,子盒子是必须重新写)</p>
<p>主要方法是,先生成固定位置的方块,然后每隔0.5秒钟重新设定一下方块的定位属性.定位和颜色随机.</p>
<p>一些细节</p>
<pre><code>制定构造函数的时候,做了一个预防性设置,就是判断有没有传参数,是一个好习惯.
设置随机生成的盒子对象的属性,然后这些属性当做样式,准备留到后面传给盒子,注意&quot;px&quot;
创建盒子的时候,那个this.div指向的是一个对象,而不是像之前一样是基本类型的数据.对象属性可以是任何
//在构造函数使用了方法调用,即使这个方法在后面写给原型,这样是可以执行的,
//因为构造函数在此时并没用调用,只有用new的时候,重新生成方块的时候它才会被执行一次.所以,执行代码是写在给原型赋值后面的
用getRandom来做的话,注一下那个函数,用了Math.floor,Math.random.
不懂.设置了一个this.parent属性来应用父盒子,而不能直接用parentNode来做,为什么?
设置数组的时候,是生成一个盒子就放到数字里面去,数组储存同名的对象,但是指向不同,
 后面大概没什么东西了.
</code></pre><p>贪吃蛇_食物</p>
<pre><code>自调用函数可以封装很多东西,让函数名字给保护起来.最后将函数的方法暴露出去
记录食物用来删除,通过数组来控制这个对象.数组,记录蛇也是这样的,所以用通用方法去解决
删除数组,直接用下标会出问题,因为数组的数据会动态变化.一个方法是从后面开始删, 一个方法是一直删0号对象.
删除的时候要注意,一定要同时删除生成的盒子和数组里面的元素,不然那个数组里面好像还保存着盒子里面的栈里面的值.  这里等下详细解释一下,大概原因是数组里面的对象虽然引用了盒子,但是没有实时更新,所以需要手动删掉数组里面的数值.
</code></pre><p>贪吃蛇_身体</p>
<pre><code>创建长高还有方向,还有body,是一个数组,里面有属性值代表身体,最后会实现吃了东西就加一个方块吧.
渲染的方法都用原型里面来做,毕竟是方法.不会有多大改变.
//渲染包括就是生成格子,代表像素,设定格子样式,长宽,位置position,颜色.
设定position是一个字符串属性值,非常不错,反正不会到定义域外面去.
</code></pre><p>贪吃蛇_移动</p>
<pre><code>可以看到 swith语句里面的defult不是必须的,如果你可以把所有情况搞好.
蛇移动的时候要先移动身体,因为身体的移动方式是跑到上一个方块的位置,等头走完了,第一个身体格子就会跑到头的后面去,只能等身体走完了,头再走就好了.
</code></pre><p>一些细节</p>
<p>一个概念笔记,很不错</p>
<p>概念笔记</p>
<p>Css各种动画,新特性,弄好了就可以了.还有js各种事件,</p>
<p>块级作用域,和此词法作用域,再根据高三来看看.</p>
<p>Object.prototype.toString.call(要判断的对象)这个方法还要看看   数据类型 判断</p>
<p>就是可以看这个东西的原型,还有 instanceof 但是是返回布尔值</p>
<p>CSS细节:在代码库里面有的</p>
<p>不分类的小细节</p>
<ol>
<li>pointer_events,这可以视线一个元素的镂空效果,就是只有样子,没有实体,可以穿过去点下面的连接等东西animation的所有参数是什么?</li>
<li>z-Index的细节,z-index有作用域,而不是全局的排序,是根据盒子父子级关系来的</li>
</ol>
<p>修改placeholder里面的文字样式</p>
<pre><code>input::-webkit-input-placeholder {
    /* placeholder颜色  */
    color: red;
    /* placeholder字体大小  */
    font-size: 12px;
    /* placeholder位置  */
    text-align: left;
}
</code></pre><p>background-size对于背景图片的作用</p>
<p>cover:等于是会裁剪图片,图片大小也会相应有点变化,然后图片会填满盒子</p>
<p>contaier:不会裁剪图片,单纯变化图片大小,让图片完全被包含在里面.</p>
<p>当宽设置成100%的时候,cover是顾高不顾宽,container是顾宽不顾高.</p>
<p>cover的时候一般配合center top来作用,也可以center center</p>
<p>设置固定的固定的像素的时候,会让图片进行相应的缩放,而一个比较有用的方式就是</p>
<p>固定值 auto ,这个固定值和之前图片大小的比例,则是背景图片缩放的比例,</p>
<p>当然要注意背景图片被缩放之后,用原图测量的背景位置,也要相应改变 </p>
<p>3D的经验</p>
<pre><code>给body设定perspective,就代表body离你有多远,然后给各个元素设定perspective,可以控制元素和你的距离,然后就可以形成大小的区别
给父盒子设置 transform-style,然后里面的子盒子进行变换操作就是3D形式了
当然,要玩变化,定位肯定要设置一下,不能让元素相互影响
要做一个立方体,就是让所有的子盒子,按一定的位置进行变换,变换的关键是transform-origin,就是位置,如果不设置的话,默认是两个百分之五十
如果是3d的translateX那是沿着顺时针来转, 但是translateY是沿着逆时针来转的,Z是顺时针
perspective可以直接写在body上,代表body这块画布有这么远,而里面的元素如果translateZ超过了这个视距,则会到后脑勺去,表现为看不见,但是其他的元素也可以用perspective视距来表示,值越小代表离眼睛越近,貌似负数的话也是看不见的
视距这个东西都只是作用其子元素的,而不是作用给自己的
比如给body一个1000px,那么元素都会有一定的立体效果
而如果给容器一个1000px,那么子元素因为离它很近,那会有很离谱的变形效果
具体看看我的css3效果探寻,如果给body设置,container没设置,还是有一定立体效果,如果都没设置,则完全没立体效果;给container,那立体效果会很夸张
</code></pre><p>动画经验是什么?</p>
<p>动画的时候最好设置初始值,虽然有时候会自动补全初始值,但貌似有时候会产生bug </p>
<p>  @keyframes                                  规定动画。                                       3<br>  animation                                   所有动画属性的简写属性，除了 animation-play-state 属性。     3<br>  animation: name duration timing-function delay iteration-count direction;<br>  animation-name                              规定 @keyframes 动画的名称。                        3<br>  animation-duration                          规定动画完成一个周期所花费的秒或毫秒。默认是 0。                   3<br>  animation-timing-function                   规定动画的速度曲线。默认是 “ease”。                       3<br>  animation-delay                             规定动画何时开始。默认是 0。                             3<br>  animation-iteration-count                   规定动画被播放的次数。默认是 1。或者是infinite                3<br>  animation-direction                         规定动画是否在下一周期逆向地播放。默认是 “normal”。 alternate是轮流方向播放    3<br>  animation-play-state                        规定动画是否正在运行或暂停。默认是 “running”。                3<br>  animation-fill-mode                         规定对象动画时间之外的状态。下面有四个.                        3   </p>
<p>  none         不改变默认行为。<br>  forwards     当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。<br>  backwards    在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。<br>  both         向前和向后填充模式都被应用。                          </p>
<p>贝塞尔曲线讲解,掌握这个完美掌握过渡和动画</p>
<p>{“ease”:”.25,.1,.25,1”,”linear”:”0,0,1,1”,”ease-in”:”.42,0,1,1”,”ease-out”:”0,0,.58,1”,”ease-in-out”:”.42,0,.58,1”,”飚速”:”.03,.97,.04,.98”,”蓄力爆发”:”.92,.05,.93,.05”,”慢快慢”:”.96,.05,.04,.94”,”快慢块”:”.03,.96,.99,.09”}</p>
<p>后来才发现,原来这个数值可以超过1的,所以可以形成返回的动态 </p>
<p>四个数，左边两个数是左下角的动点的坐标，右边两个数是右上角的动点的坐标。</p>
<p>拉动两个点，可以共同控制这个曲线，</p>
<p>左下角的点，越往左上位置摆放，曲线的前半部分会越陡峭，就是会更快；</p>
<p>右上角的点，越往右下位置摆放，后半部分会越陡峭，会更快。</p>
<p>反正几个比较关键和变态的点都写上了。实在搞不清了，就用上面的坐标去对照就好了</p>
<p>matrix详解</p>
<p>matrix详解</p>
<p>transition的讲解,不错的</p>
<p>Js基础</p>
<p>不分类的小细节</p>
<ol>
<li>document.getElementById.如果没找到,返回的是null.</li>
<li>input:button里面可以直接用onclick写效果.</li>
<li>alert接受参数时,会自动将参数调用toString方法.</li>
<li>函数在设置参数的时候,本身自带 var parameter效果.如果重新用了 var 来定义,就是重新定义一个变量.</li>
<li>之前我们做了拖拽特效,但实际上可以给标签设置一个拖拽属性<p draggable="true" ondrag="myFunction(event)">拖动我!</p>,并且可以添加拖拽事件</li>
<li>有一个事件叫做load事件,有个DOMContentLoaded,这两个的区别是,load是等图片和外部文件都加载完才出发,而另一个,不用</li>
<li>自调用函数写的时候,一定要在自调用前面写个分号,防止结合起来,当做一个函数.</li>
<li>自调用函数会传入window和undefined参数,传入window之后可以让代码里面的window被重新压缩.<br>传入undefined话是为了防止undefined值被人工改变.这样子吗 </li>
<li>innerHTML 赋值的时候会重新赋值, 所以次数越少越好,<br>字符串拼接会耗费大量资源,不如用数组来做.</li>
<li>e.preventDefault() //这里是取消默认,也可以用来取消这个事件吗</li>
<li>用相等性判断的话 , 那用switch 是最好的方式,而不是if之类的</li>
<li>var endDate = new Date (‘2017-11-11 0:0:0’)  日期的格式是这样子搞得.</li>
<li>用prompt来提供值的时候,它的类型一直都是字符串类型,如果输入数字,在运算时候会转换成数字,但是判断布尔类型的话,行不通的.</li>
<li>颜色的值只能是整数,rgb(11.11,22.1,22)这样是无效的.</li>
<li>输入框里面输入一个值,如果是要在鼠标出去的时候获取value值,那么用onblur来做比较好,失去焦点.</li>
<li>界面的id是唯一,如果不是严格模式,直接写id再操作的话可以直接操作,而不用getElementById来操作.</li>
<li>addeventlistener据说在后面还用得蛮多的,因为可以给新创建的元素添加事件,并且不会覆盖之前的</li>
<li>select 和options的事情, select是一个选择栏, 选择栏的value值就是当前选择的option的value值,所以给options分别设定value值,然后再选择select,获取select的value值就知道选择了哪一个.</li>
<li>循环的 i,是index的意思.至于 j,就不知道了.貌似是根据数学里面向量的用法, ijk.</li>
<li></li>
</ol>
<p>数组的几个迭代方法</p>
<p> every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。</p>
<p> filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</p>
<p> forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</p>
<p> map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</p>
<p> some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 。</p>
<p>参数都是三个 (value ,index,array)</p>
<p>every 和some是布尔值的判断, 一个是交集,一个是并集 , </p>
<p>filter用来过滤返回true的值</p>
<p>foreach和map是比较简单实用的.</p>
<p>js的函数没有重载,是什么意思?</p>
<p>函数重载就是说函数名是一样的,只是由形参的的不同来区别函数,就是允许同名的多个函数,是c++里面的,而高三111页说js函数没有重载,意思是说同名函数会进行覆盖,只学过js可能会觉得理所当然,因为js里的变量不用指定类型,但是其他语言需要提前指定类型来声明,而重载函数就可以让同名函数处理不同类型的实参.</p>
<p>函数参数与函数的一些细节</p>
<p>函数的参数可以在定义的时候声明形参,但即使你没定义,你也可以使用,只要在函数里面使用arguments[0],就获得执行时候输入的参数.auguments是函数执行时活动对象的一个属性,</p>
<p>同时,也可以通过  函数名.arguments来访问实参,当然要注意不能有和 函数同名 的变量或者参数来覆盖.</p>
<p>而在代码里直接打印函数,那只是函数体,它的arguments属性是空,</p>
<p>arguments还有一个callee属性,返回函数体本身.</p>
<p>函数的length属性,是创建的时候设定的形参的数量,</p>
<p>pageX clientX screenX offsetX  的区别?</p>
<p>pagex和clientx比较容易搞混,一个是当前浏览器距离加上参考滚动的值,一个是当前浏览器距离</p>
<p>screenx是相对屏幕的 不只是浏览器,是整个屏幕都能判断, </p>
<p>offsetX是相对上一个有定位的父级元素的位置.</p>
<p>页面滚动坐标的3个种识别</p>
<p>window.pageYOffset   …document.documentElement.scrollTop         …document.body.scrollTop</p>
<p>offsetHeight和style.height的区别有哪些？</p>
<p>style.height只能获取行内样式,这样子好像确实是的, offsetwidth和getconputedstyle之类的也不错.</p>
<p>style.height是字符串(而且带单位)</p>
<p>style.height可以设置行内样式,offset是只读属性</p>
<p>一般用offset来获取元素的宽度和高度,用style.height/width来设置宽度/高度</p>
<p>正则表达式全局提取时候的while循环</p>
<pre><code>var regChinese = /a/g; 
var some;  
     while (  some = regChinese.exec(&apos;adasdfasdfad&apos;)){
       console.log(some);  
       //如果 console.log(regChinese.exec(&apos;adasdfasdfad&apos;)) ,则打印的时候也调用了一次函数,那么会提取一次,
       //那么在循环里面再调用的时候,中间已经隔了一次提取了,
       //如果可以提取的个数有点问题,可能会形成死循环,因为while判断可能一直被提取到了的数字控制,而不是null.
     }
</code></pre><p>return break continue 的区别</p>
<p>return 一般是用在函数里面的,用来返回值,return下面的东西不会执行,就跑步到了终点,终点后面的速度不会再记录</p>
<p>break continue是用来循环的</p>
<p>break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号）(从当前循环的顶部继续执行.) </p>
<p>continue:立即跳出当前循环，继续下一次循环（跳到i++的地方）</p>
<p>label  设定标签.  label: 语句,  然后用continue和 break可以跳到标签所在的位置.一般用在for里</p>
<p>引用continue的话只是退出当前循环,而不会影响下一步循环,或者外层循环. </p>
<p>带参数的函数,它预解析的时候根据以下逻辑</p>
<pre><code>&apos;参数的声明和赋值,注意是赋值,也是在预解析之前的&apos; 这是老师的说法,
  //但实际上,大概是参数的赋值和函数的赋值一样,在声明的时候有两个做法,一个是声明,外加绑定参数.
  //这样子的话就很好理解了.就像函数声明,先声明变量,再绑定函数,只是参数在函数前面执行.
(function ( a ) {
        console.log( a ); //打印函数体
        var a = 10;
        console.log( a ); //10
        function a () {
            console.log( a );
        }
        a(); //报错
    })( 100 );  
如果穿进去了参数,然后函数里面声明了变量,打印的话是参数,而不是变量的undefiend;
某个变量名 &gt; 是否有参数? 有 &gt; 参数 &gt; 是否有函数? 有&gt;函数(函数会执行表达式和执行块)
                               无 &gt; 变量 
然后再正常执行程序
</code></pre><p>词法作用域的总结?  有个老师的笔记总结的很好</p>
<pre><code>1. 在 没有函数的情况下, 所有的变量的访问规则依据预解析规则
2. 只有函数可以限定作用域其他的不行
3.在函数内部是一个独立的完整的作用域结构
//里面和外部完全是一样的,它的预解析过程是一样的,只要进入函数,就开始预解析
4. 在函数内部, 允许再定义函数. 同时两个层次的函数都是作用域的独立体
5.允许在函数内, 访问函数外的变量. 前提是函数内没有该变量的声明( *** )    
                                   //如果有的话,只会先找内部的变量的申明,只是声明而不是赋值
 //一个总结
                                   结论:
            词法作用域就是描述变量的访问范围:
            1&gt; 在代码中只有函数可以限定作用范围. 允许函数访问外部的变量. 反之不允许.
            2&gt; 在函数内优先访问内部声明的变量, 如果没有才会访问外部的.
            3&gt; 所有变量的访问规则, 按照预解析规则来访问
</code></pre><p>作用域的寻找和查找属性方法的寻找方式有什么联系吗? 只是类似吗?</p>
<p>似乎没什么关系,只是查找属性的方式是一样的,类似的, 似乎并没有更内在的内在联系</p>
<p>怎么手动10进制变换2进制?</p>
<p>用数字一直除以2,然后用右边的余数,如果是0,也写下来,这些余数一直一直下来,一直到最后一个,然后反向连接起来.</p>
<p>具体是什么原理我还是要看一下,大概一个数字如果可以多次除以2,那还原的时候要多次乘以2 </p>
<p>一种遍历创建方法</p>
<pre><code>for (var i = 0, len = newsContainer.children.length; i &lt; len; i++) 
//这种写法,也可以,可以让length在创建函数的时候才创建.
</code></pre><p>判断类样式中是否已经有hide(某个样式)</p>
<pre><code> if (div.className.indexOf(&apos;hide&apos;) === -1) {
      div.className = &apos;news-b hide&apos;;
    }  //indexOf字符串方法,字符串如果找到了对应的字符串则会返回一个下标数字,如果没找到则返回-1
//用这种放来测试类名里面的方法
</code></pre><p>这个方法可以用的地方似乎还是挺多的?</p>
<p>关于进制的转换</p>
<pre><code>parseInt 用来转换的话,可以设置两个参数,如果只用一个参数的话就是默认模式;如果两个参数,后面的数字代表这个数字的进制,
number的toString方法可以有默认模式和参数模式,参数模式下会返回数字的特定进制数字.
比如 255.toString(16) 会返回FF值.
</code></pre><p>数组方法中的sort()实现数字的排序</p>
<pre><code>//如果没有输入参数,那是直接  按照字符编码的顺序进行排序 ,里面都会变成字符编码的顺序
如果要用数字的来排序,那是要用一个排序函数
function sortNumber(a,b)  //这个函数就是里面的
{
return a - b
}  
//如果要用的话就是,卡主了 .  arr.sort(sortNumber) .这样子来的
</code></pre><p>tips,这个方法和reverse方法都会改变原来数组, </p>
<p>数组方法和字符串方法一些共同点和差别分别是什么?</p>
<p>数组也是一个对象,可以用for in 来遍历,这个,而不用for循环.</p>
<pre><code>//数组有很多方法,记起来很麻烦,但是记住分别能干什么事比较靠谱的.
数据检测:
//包括 instanceof Array 和Array.isArray,字符串倒是不确定,不过instanceof是有的
转换方法:
//数组的话有四个,toString,valueOf,toLocalString,还有join,前面三个大多返回的是逗号分隔的字符串,而join可以设定中间以什么分隔;  字符串转换数组:那就是spilit的方法.参数是用什么字符来分割.
堆栈方法:
//数组可以用unshift和push来添加一个或多个元素,返回值是添加之后数组的长度;   而shift和pop则是减少一个元素,返回值是减少的那个元素;    而字符串,似乎没有对应的方法???
注意:排序方法:
//数组有reverse()和sort(),都可以改变原来数组的顺序.     而字符串,则也没有对应排序方法,不过可以把字符串转换成数组后再排序
操作方法:
//concat( )数组和字符串都有这个方法.创建新的  
// 数组的slice(start,end),如果只有一个参数,则截取起始项到最后的那个;  如果参数是负数,则返回项等于长度减去数字. 如果起始项大于截止项,则返回空数组. 
//字符串也有个slice,和这个差不多
//splice ,数组中非常强大的方法,可以有3个参数,第一个是起始位置,第二个是删除项数,第三个是插入项,而数量可以是任意多,就是说,可以用这个在数组任意位置删除多个项或者插入多个项.也可以同时做; 它返回的是被删除的项所组成的 数组.
//字符串的话还有substring() ,substr()和slice三个效果差不多,但是substring不接受负数参数,substr没有标准化一般不建议使用,slice比较靠谱
//slice(start,stop)是从start下标到stop下标,不包括stop,,而substr(start,length)是从从a下标开始截取b个元素,而substring(start,stop),也不包括stop.
位置方法:
    //数组有indexOf和 lastIndexOf, 字符串也有,如果都不存在的话返回-1;
迭代方法:
     every,filter,forEach,map,some
    //方法接收两个参数,一个是函数,另一个是运行该函数的作用域, this, ,
    //运行的函数又接收三个参数,数组项的值,该项在数组中的位置,以及数组对象本身.
    //这几个方法看起来都很强大,every和some来判断满足条件,filter返回满足条件所组成的数组
    //foreach只是运行函数,而不返回值
    //map可以返回一个数组,是每个元素运行函数后的返回值的集合
</code></pre><p>字面量创建的对象和字面量创建的数组差不多是一个意思,为什么?</p>
<p>var arr = [];  var arr = [aaa,aaa,aaa,aaa]; //都是用逗号分开,而数组的下标等于是对象的属性,</p>
<p>var object = {} ; var object = {属性:属性值,属性:属性值}; 这个差不多就是一样的.</p>
<p>DOM</p>
<p>top是window的一个属性,如果用top来作为变量名的话会失效;</p>
<p>这门语言为创建对象的做了哪些相关优化?</p>
<pre><code>字面量和函数都可以直接返创造对象,但构造函数是创造对象更好的方式.
//如果不用prototype添加属性,自带的方法会在每次调用的时候重新开辟内存空间,当然也可以在外面写入函数,然后指向那个函数,不过会带来函数命名问题,因为有可能有多个对象用相同的命名.
//构造函数创造的对象会有一个constructer属性,返回创造它的构造函数
//同时,每个构造函数有个prototype属性,指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承;;我们可以把那些不变的属性和方法，直接定义在prototype对象上。
　function Cat(name,color){
　　　　this.name = name;
　　　　this.color = color;
　　}
　　Cat.prototype.type = &quot;猫科动物&quot;;
　　Cat.prototype.eat = function(){alert(&quot;吃老鼠&quot;)};
//这样子的话,可以节省内存
为了配合prototype属性,它下面有一些方法,
  //isPrototypeOf()  这个方法用来判断，某个proptotype对象和某个实例之间的关系。

//hasOwnProperty() 用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性。如果是继承的prototype属性就会返回false.  
  alert(cat1.hasOwnProperty(&quot;type&quot;)); // false
//in运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。 
//alert(&quot;name&quot; in cat1); // true
//in运算符还可以用来遍历某个对象的所有属性。 
//for(var prop in cat1) { alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); }
对象除了创建的时候为了减少内存而产生了prototype,还有别的东西,就是继承,我暂时也不太清楚
//详情看我代码,概念的例子. 面向对象编程,封装
一.构造函数继承
//Animal.apply(this, arguments); 就是在子构造函数里面添加一行代码,animal在这里是父级构造函数,this在子构造函数里指代的是子构造函数,argument是用子构造函数生成时候传入的参数.
二. prototype模式
Cat.prototype = new Animal();  //prototype本身就是指向一个对象,而用这个指向一个新的animal之后,它的属性都会转到animal
    //每个构造函数生成的对象都有一个constructer属性,默认是构造函数的prototype.constructer.
    //当运行第一行后,用Cat生成的对象它的constructer属性也会变成 animal.这样是不对的,所以后面一定要手动改回来
    //这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象，
    //那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。
Cat.prototype.constructor = Cat;  
//就是先用原型对象 指向父对象,然后再把构造函数手动改回来
三、 直接继承prototype
先要改写父对象
//function Animal(){ }
　　//Animal.prototype.species = &quot;动物&quot;;  //之前是　this.species = &quot;动物&quot;;
然后
　//Cat.prototype = Animal.prototype;
　//　Cat.prototype.constructor = Cat;
　//　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);
第二步还是不能省,
  //缺点是animal对象的原型和cat对象的原型变成一个了,如果进行了修改,animal也改掉.
  四.用一个空对象来接受原型,等于是调换两个值,中间加了一个temp
五.拷贝所有的父对象属性方法放到子对象里面去.
 function object(o) {
      function F() {};  // 假设一个创建函数的对象
      F.prototype = o;  //它的原型是那个被复制的对象,就是说添加了所有的那个对象的属性和方法
      return new F();  //返回一个实例, 这里注意new.
    }  
  卧槽..还是看这个链接吧,太多了

还有还写了非构造函数对象的继承方法,就是jQuery的方法. 
</code></pre><p><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html</a></p>
<p>javascript定义’类’的三种方法</p>
<p><a href="http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/07/three_ways_to_define_a_javascript_class.html</a></p>
<p>类就是一个创建对象的模板,这个模板怎么用非常有意思.</p>
<p>高级JS</p>
<p>面试经验</p>
<p>面向对象是一种设计思想,创造的代码性能好些,能够比较好的增删查改,比如命名封装,而且在和别人联合工作的时候会更方便.面向对象就像给代码里面的每个东西添加索引,索引在哪就是哪个.</p>
<p>简历的话可以拿回来,也可以简历都不带, 真的骚.</p>
<p>一些细节</p>
<ol>
<li>当开发工具里面报错,可以看得到.<br>但是在某个函数里面,比如你显示某一行报错,其实可能是调用的参数没有给对,那也会报错.</li>
<li>在函数里面可以直接访问设置arguments,但是调用的时候才会知道arguments的值</li>
<li>属性如果打印出来没有的话是会显示undefined</li>
<li>var tag = document.getElementsByTagName;  var p = tag.apply(document,[‘p’]); 这个要这么做 </li>
<li>apply等改变作用环境时候,不能忽略这点事实,被当做环境的对象能够使用这方法,如果对象不能使用这函数,那还是会报错.</li>
<li>属性放到构造函数里面,方法放到原型里面</li>
<li>早绑定和晚绑定 –w3c手册对象应用一页   , 甚至还有一个 极晚绑定  –w3c修改对象那一页</li>
<li>callee是arguments对象的一个属性,返回的是正在执行的函数本身的引用,哪个函数的argument的callee属性就指向哪个函数.而caller,是当前调用这个函数的函数的引用,如果在全局作用域中调用该函数,则返回null,因为全局对象不算函数吧,虽然也可以算,因为打开浏览器就会执行.</li>
<li>对象的属性有4个特性来描述它,分别是可否删除,可否遍历,可否修改,属性值,前3默认是true,最后一个是属性值. Object.defineProperty()这个方法可以修改,可以用这方法让属性无法遍历,enumerable:false –详见高三140<br>还可以通过别的方式来批量修改属性值,不过浏览器兼容有问题.</li>
<li>有个深浅复制的区别,应对复杂数据类型的.浅复制只复制一层对象的属性，而深复制则递归复制了所有层级。因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以两个对象会共同指向同一个内存地址.而深复制则不会那样.</li>
<li>自执行函数的(function(){   })();  这样的形式,前面的括号其实是让 函数的声明先执行,就是让函数声明变成一个函数表达式,像var a = function (){} ,前面的a也只是一个指针,当然可以直接用等号后面的声明来代表这个a,而加了括号,就是转变成了函数表达式,再加个括号就是执行.</li>
<li></li>
</ol>
<p>js中表达式和语句的区别</p>
<p>一个链接,讲得不错</p>
<p>构造函数的一些细节</p>
<pre><code>构造函数的方式是new,1创建新对象,2构造函数的作用域变成新对象,3一一赋值4返回新对象.

所以,如果没有new的话,那么执行了之后会给window赋值,就是说,可以再外面直接使用变量了.而你本来用来接收对象的变量,则会变成undefined,因为构造函数没有返回值.

构造函数的问题在于,每个方法都是在每个实例上重新创建一遍的.一个不完善的解决方法是把函数放到全局函数然后引用,而更好的方法是原型来引用.

原型对象的设计就是用来解决这个问题的,

实例属性会覆盖原型属性的获取,但是不会改变原型属性.如果用delete删除,这个属性,就可以重新访问原型属性.

function Product(a,b) {
    this.a=a;
    this.b=b;
}
var test = new Product(&apos;aaa&apos;,&apos;bbb&apos;);
var a =Object.getOwnPropertyDescriptor(test, &apos;a&apos;); //注意前面是对象,后面是属性名字(字符串)
console.log(a)  
</code></pre><p>hasownproperty 实例的属性</p>
<p>hasPrototypeProperty()  如果实例中没有而原型中有,这个方法会返回true,如果都有,那就返回false,还是覆盖效果</p>
<p>in 的方法则是所有都能获取到的</p>
<p>Object.getOwnPropertyNames()  这个方法可以获取不可以枚举的属性</p>
<p>在原型上添加属性很麻烦时,可以一次性将构造函数的原型变成一个字面量,然后里面设置一个constructor属性来指回原对象,然后用</p>
<p>Object.defineProperty(Person.prototype, “constructor”, {</p>
<p>enumerable: false,</p>
<p>value: Person</p>
<p>});    //这样来将原型的可枚举型变为false, 不过这样也太麻烦了吧, 不过对对象的理解倒是加深很多.</p>
<p>不过如果你是先创建实例对象,再重写整个prototype对象,那么返回不会动态的给添加上. 它引用的还是以前的原型.</p>
<p>因为实例中的指针只是指向原型对象,而不是指向构造函数,</p>
<p>还有一个问题:原型里面的值,如果是引用类型的话,那么在一个实例里面修改这个值,则另外一个实例也会共享这个东西.所以要看你自己的需求了,如果需要这个值被共享的话就引用起来也没问题.</p>
<p>构造函数和原型模式组合起来的模式是目前的最通用的方式.</p>
<p>寄生构造函数模式 ==&gt;所谓寄生,大概是使用了new 。除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的.   所以也没有原型的概念,也不能用instanceof操作符来创作.</p>
<p>高三书里提到了道格拉斯克劳福德(Douglas Crockford),就是写javascript语言精粹的那个,</p>
<p>创建了 稳妥构造函数模式,创建了稳妥对象(durable objects):没有公共属性,它方法也不应用this的对象.</p>
<p>这个对象适合在安全环境中使用(禁用了this和new),这个东西创建就是不使用this,也不用new来创建</p>
<p>一个创建的稳妥对象,里面的数据,只有构造对象时的函数来获取,</p>
<p>`这个东西并不是一般的对象,而是用一个方法来操作参数,因为只有这个函数里面的方法能获取到参数,而用这个函数创建对象完成之后,再添加prop的话也跟参数没关系了.</p>
<pre><code>这样，变量 friend 中保存的是一个稳妥对象，而除了调用 sayName() 方法外，没有别的方式可
</code></pre><p>以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传</p>
<p>入到构造函数中的原始数据。稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环</p>
<p>境——例如，ADsafe（www.adsafe.org）和 Caja（<a href="http://code.google.com/p/google-caja/）提供的环境——" target="_blank" rel="noopener">http://code.google.com/p/google-caja/）提供的环境——</a></p>
<p>下使用。</p>
<p>私有变量  //高三186页</p>
<p>提到js中没有私有成员的概念,这个似乎是c++有关的, 定义类的的同时定义 private  public 和 protected.</p>
<p>任何在函数中定义的变量,都可以认为是私有变量,因为没法在函数外面访问到.就是作用域的问题 </p>
<p>而把有权访问私有变量和私有函数的公有方法称为特权方法（privileged method）。</p>
<p>有两种方式,</p>
<p>一种是构造函数中定义方法,因为方法在引用了构造函数的活动对象,作为闭包.构造函数的实例是公有的,并且可以引用里面的变量.</p>
<p>又提到私有和特权,两个属性叠加,可以隐藏那些不应该被直接修改的数据,如下 </p>
<pre><code>function Person(name){
this.getName = function(){
return name;
};
this.setName = function (value) {
name = value;
};
}
var person = new Person(&quot;Nicholas&quot;);
alert(person.getName()); //&quot;Nicholas&quot;
person.setName(&quot;Greg&quot;);
alert(person.getName()); //&quot;Greg&quot;   //就是说,可以用参数的性质来储存数据,而实例的方法,可以获取和改变参数的值.
</code></pre><p>静态私有变量</p>
<p>就是在函数中定义一个不加var全局构造函数,然后在原型上添加一个方法,这个构造变成全局,就是公有的.而它的原型方法在私有作用域中定义,同时保存了对私有变量和函数的引用.</p>
<p>这个方法的特点在于,所有的实例都可以访问这个变量,是共享的,可以用到什么地方呢? </p>
<p>模块模式</p>
<p>这个感觉好牛逼,</p>
<p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模（modulepattern）则是为单例创建私有变量和特权方法。</p>
<p>就是说,它不是共享的, </p>
<p>它的模式是用一个函数,先定义私有变量和私有函数,然后最后return一个对象, 这个对象包含对私有变量和方法的操作.还是发一下代码吧.</p>
<pre><code>var singleton = function(){
//私有变量和私有函数
var privateVariable = 10;
function privateFunction(){
return false;
}
return {
publicProperty: true,
publicMethod : function(){
privateVariable++;
return privateFunction();
}
};
}();
console.log(singleton)  //打印出来可以看[[scope]]属性,在里面找到第一个closure定义域.里面有保存着的私有变量和方法, 而你只能通过这个对象,来操作它

从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，
</code></pre><p> 简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有</p>
<p>数据的方法，那么就可以使用模块模式</p>
<p>可以用这个单例来管理应用程序的信息??</p>
<p>增强的模块模式</p>
<p>增强模式的话,相比上面的模式,可以让这个单例变成某个对象的实例,而上面的方法都是object.</p>
<p>它是定义了私有属性和变量之后,再创建一个对象的实例,之后添加特权/公有的方法, 然后返回这个对象.</p>
<p>这样子之后</p>
<p>继承和原型链</p>
<p>原型链的设计模式和作用域链[scope chain]的模式是一样,就是循环一个过程,把外层的放到外面,里层的放到前面.</p>
<p>用一个属性来指向相应对象,如果它身上本身有对应数据,则返回,不然则通过指针去尝试到链条外层查找.</p>
<p>看原型链的方式,即使存到后面原型的方法,也会从对象的实例属性一层层去找,似乎调用了类似call和apply的方法.</p>
<p>所以在原型上面的this,也会引用到调用它的实例 </p>
<p>instanceof 和  isPrototypeOf 是确定原型和实例对象的关系的两种方法</p>
<p>将超类型的实例赋值给子类型的原型,这样便可以形成原型链,</p>
<pre><code>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎
</code></pre><p>样，给原型添加方法的代码一定要放在替换原型的语句之后。</p>
<p>意思是,如果放在前面添加,那替换了之后就失效了 </p>
<p>原形链的问题</p>
<pre><code>其中，最主要的问题来自包含引用类型值的原型。

原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。
</code></pre><p>借用构造函数（constructor stealing 偷取）,也叫伪造对象或经典继承</p>
<pre><code>function SuperType(name){
this.name = name;
}
function SubType(name,age){
//继承了 SuperType，同时还传递了参数     
SuperType.call(this, name);
//实例属性
this.age = age;
}
var instance = new SubType(&apos;coldi&apos;,10);  //传进去,可以用上另外一个构造函数
console.log(instance); 
</code></pre><p>相对于原型链,这个的好处是可以传进去参数.但是,问题在于,和构造函数一样,没有函数复用了,所有方法都重新创建的.而且,超类型的原型,并没有继承到.</p>
<p>组合继承（combination inheritance） //原型链和借用构造函数的结合</p>
<p>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数</p>
<p>就是说,子类型实例本身和它的原型上都会有相同的属性.</p>
<pre><code>function SuperType(name){
this.name = name;
this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
console.log(this.name);
};
function SubType(name, age){
//继承属性
SuperType.call(this, name); //这里面用call来借用构造函数
this.age = age;
}
//继承方法
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;  //因为重写后这个属性会消失掉.就需要重写一下,不然会变成superType,这一步是不可少的,如果愿意的话可以把这个属性变成不可遍历的
SubType.prototype.sayAge = function(){
console.log(this.age);
};
</code></pre><p>原型式继承 </p>
<p>就是把用一个函数,函数里面声明一个构造函数,然后拿一个已知的对象当做构造函数的原型,最后返回一个新的实例</p>
<p>还有一个原生的Object.create方法,和这个方法一样,只是可以放两个参数.第二个参数是添加额外属性的对象.</p>
<pre><code>function object(o){
function F(){}; //这个是
F.prototype = o;
return new F();
}
var person = {
name: &quot;Nicholas&quot;,
friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = object(person);
anotherPerson.name = &quot;Greg&quot;;
anotherPerson.friends.push(&quot;Rob&quot;);
var yetAnotherPerson = object(person);
yetAnotherPerson.name = &quot;Linda&quot;;
yetAnotherPerson.friends.push(&quot;Barbie&quot;);
alert(person.friends); //&quot;Shelby,Court,Van,Rob,Barbie&quot; 
//这个方法也是公用原型的,会共享数据
</code></pre><p>寄生式继承</p>
<pre><code>function createAnother(original){
var clone = object(original); //通过调用函数创建一个新对象,上文的object函数/
clone.sayHi = function(){ //以某种方式来增强这个对象
alert(&quot;hi&quot;);};
return clone; //返回这个对象
}
var person = {
name: &quot;Nicholas&quot;,
friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //&quot;hi&quot;,就是这样的,
//使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。
</code></pre><p>寄生组合式继承</p>
<pre><code>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.
</code></pre><p>prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用</p>
<p>instanceof 和 isPrototypeOf() 。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<pre><code>function inheritPrototype(subType, superType){
var prototype = object(superType.prototype); //创建对象  ,这方法还是之前的object
prototype.constructor = subType; //增强对象
subType.prototype = prototype; //指定对象
}
////
function SuperType(name){
this.name = name;
this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
alert(this.name);
};
function SubType(name, age){
SuperType.call(this, name);
this.age = age;
}
inheritPrototype(SubType, SuperType); //这里调用了一次
SubType.prototype.sayAge = function(){
alert(this.age);
};
</code></pre><p>据说这个就是最理想的继承方法了.效率最好,指向也是准确的.没什么缺陷.</p>
<p>for in 的一种特别的用法, 用例子来看</p>
<pre><code>var obj = {
    a:1,
    b:2,
    c:3
}
function keys(obj){
    var a = [];
    for(a[a.length] in obj); //这一步还可以这么做的??给数组赋值的用法
    return a ;
}
console.log(keys(obj))
//可以让对象的属性值,全部赋值到数组的值里面,这个东西..
</code></pre><p>ECMAscript对象小解</p>
<p>本地对象、内置对象和宿主对象。</p>
<pre><code>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。  w3c
</code></pre><p>这些类是作为原生构造函数的对象.比如Object,Function,Array之类的</p>
<p>内置对象包括全局对象(Global)和Math对象,</p>
<p>它们是预定义的对象,自身不是某种对象的类,也不是某个对象的方法,没有构造函数Math(),只要把Math当做对象直接使用即可.</p>
<p>全局对象很牛逼,全局对象不是任何对象的属性,所以没有名字.而在浏览器中,window对象就是全局对象</p>
<pre><code>全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。
</code></pre><p>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。</p>
<p>全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。</p>
<p>在 JavaScript 代码嵌入一个特殊环境中时，全局对象通常具有环境特定的属性。实际上，ECMAScript 标准没有规定全局对象的类型，JavaScript 的实现或嵌入的 JavaScript 都可以把任意类型的对象作为全局对象，只要该对象定义了这里列出的基本属性和函数。例如，在允许通过 LiveConnect 或相关的技术来脚本化 Java 的 JavaScript 实现中，全局对象被赋予了这里列出的 java 和 Package 属性以及 getClass() 方法。而在客户端 JavaScript 中，全局对象就是 Window 对象，表示允许 JavaScript 代码的 Web 浏览器窗口。–w3c</p>
<p>上面的第一个绿色可以用一个代码来证明,可以看到后面有a和b还有variable,</p>
<pre><code>var a=1;
var b=2;
var variables = &quot;&quot;;
for (var name in this) 
{
variables += name + &quot;&lt;br /&gt;&quot;; 
}
document.write(variables);
console.dir(this)  //可以看到console.dir里面的并不一样,那些对象大概是宿主环境提供的,包括dom和bom,,,但是这里还是要求证一下
</code></pre><p>而宿主对象,则是所有的非本地对象,由宿主环境,既浏览器或者服务器端的宿主决定,所有BOM和DOM都是宿主对象</p>
<p>面向对象语言的要求</p>
<p>一种面向对象语言需要向开发者提供四种基本能力：</p>
<ol>
<li>封装 - 把相关的信息（无论数据或方法）存储在对象中的能力 </li>
<li>聚集 - 把一个对象存储在另一个对象内的能力 </li>
<li>继承 - 由另一个类（或多个类）得来类的属性和方法的能力 </li>
<li>多态 - 编写能以多种方法运行的函数或方法的能力 </li>
</ol>
<p>ECMAScript 支持这些要求，因此可被是看做面向对象的。</p>
<p>封装插件或者函数细节</p>
<p>ajax里面学了一个封装的案例,讲解了一些封装的思想.</p>
<p>对于封装方法，我们主要要考虑几个方面：</p>
<p>1、  哪些东西是变的。 //可变的,才作为形参抽象出来,然后用实参去自己设定</p>
<p>2、  哪些东西是不变的。//不变的,代码就只写一次,多余的代码都不要</p>
<p>3、  如何将结果通知调用者。 //最后获取后台数据时,该如何处理这个数据,写一个回调函数</p>
<p>4、  如何调用方便。 //解决参数顺序问题,解决参数默认值问题,反正就是方便调用</p>
<p>5.封装的时候不需要在一个模块里面放太多东西,只要按模块封装好就好了,然后不同模块也利于别人使用,就像zepto那样,</p>
<p>用要看例子的可以看源代码,下面自己写写里面的细节</p>
<pre><code>参数用对象的属性值形式来传递,用来解决第4点,如何方便调用.
//设置默认参数对象,再用实参的属性值来替换默认参数对象的属性值,用了一个for in循环,可以实现对应属性覆盖,就是说,如果实参有这个属性,那么会被传进去,如果没有这个属性,则会用默认值
处理参数时候很关键,因为get和post的两种方法在准备和发送阶段都不一样,上代码
var params = &quot;&quot;;  //参数为空字符串
for(var attr in defaults.data){ //用JSON数据的形式来传递参数,并且可以传递多个参数.因为参数要传递的格式  param=value&amp;param=value是这样,所以做下列字符串拼接,并且去掉最后面的&amp;
    params += attr + &quot;=&quot; + defaults.data[attr] + &quot;&amp;&quot;; //多了个&amp;
}
if(params) { //因为参数可能是空,所以还要判断一次
    params = params.substring(0,params.length - 1); // 这里是去掉这个&amp;符号
    }
if(defaults.type == &quot;get&quot;) { //如果类型是get,那么在open阶段就把参数写在URL后面,用问号拼接
    defaults.url += &quot;?&quot; + params; //原本的路径后面加上问号和参数
    }
xhr.open(defaults.type,defaults.url,defaults.async);

if(defaults.type == &quot;get&quot;) { //这一步很简单
        xhr.send(null);
    } else if(defaults.type == &quot;post&quot;) {
        xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        xhr.send(params);
    }
第四个步骤是先判断同步还是异步,决定是否要用事件,然后判断数据类型,三种数据类型都有不同处理,json要转换成对象,xml就直接用上了,这个使用的话是标签,如果是字符串就直接使用.当然了这个是由实参决定.最后设置一个处理结果的函数
</code></pre><p>闭包,作用域和作用域链属性的相关联系</p>
<p>高三中似乎将闭包定义为父函数中的子函数,不管这个子函数有没有被return出来,只要能够访问父函数的中的变量,都被称为闭包,而我们所说的闭包,没有完全封闭,return了之后才是闭包. </p>
<p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最</p>
<p>后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。–高三181页</p>
<p>就是说,闭包访问到父函数的中的变量之后,如果处理变量之后返回一个值,那它是活动对象中的值,是会动态变化的,具体可以看看书上的例子.</p>
<p>作用域中的活动对象,下面有个例子可以看看</p>
<pre><code>function createFunctions(){
var result = new Array();
for (var i=0; i &lt; 10; i++){
result[i] = function(){   //在这里引用的是一个函数的返回值,而这个函数是复杂类型,这10个函数,每个函数的作用域链中都保存着createFunctions函数的活动对象.所以引用的是同一个复杂类型的值.
return i;
};
}
return result;  //按道理是返回索引值的,但是实际上, 调用的时候会全部索引同一个对象
}
//而修改成这样可以数据得到预期效果
function createFunctions(){
var result = new Array();
for (var i=0; i &lt; 10; i++){
result[i] = function(num){
return function(){
return num;
};
}(i);
}
return result;
}
</code></pre><p>闭包的作用</p>
<p>  闭包可以使的程序更加简洁优雅，合理的使用闭包有如下的作用：</p>
<p>提升程序效率:因为闭包可以访问父函数的成员变量，合理的使用闭包能够减少全局变量的数量。</p>
<p>封装与对象:通过闭包可以模拟对象的行为。这个确实是的,很像 </p>
<p>看了网上几个帖子,也有人介绍高三写的第四章</p>
<p><a href="http://www.cnblogs.com/dolphinX/archive/2012/09/29/2708763.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphinX/archive/2012/09/29/2708763.html</a></p>
<p>先介绍了一个案例,这个案例让之前的理解是onclick事件是一个回调函数,当点击的时候里面的i已经递增到4了,而这里提供了另外一种思路,这个onclick作为一个内部函数化,引用了外部的i,所以i的值一直..这里大概讲错了,这里的i本来就是全局变量.</p>
<p>闭包的实现是定义在函数中(外部函数)的内部函数可以逃脱外部函数的作用域,可供更外面作用域来使用.</p>
<p>可以将内部函数赋值给一个预先定义好的外部变量;;也可以通过外部函数return这个内部函数,然后让一个外部变量接收.</p>
<p>这种即使离开函数作用域的情况下仍然能够通过引用调用内部函数的事实，这里的引用,大概是指用变量接收内部函数 意味着只要存在调用内部函数的可能，JavaScript就需要保留被引用的函数。而且JavaScript运行时需要跟踪引用这个内部函数的所有变量，直到最后一个变量废弃，JavaScript的垃圾收集器才能释放相应的内存空间（红色部分是理解闭包的关键）。</p>
<p>闭包是指有权限访问另一个函数作用域的变量的函数，</p>
<pre><code>当外部变量接收了这个内部函数,&apos;&apos;就存在了调用内部函数的可能&apos;&apos;,就是说当又声明了一个 var a = outerfunc(),这里的a变量接收了,就是引用了这个内部函数,如果这个a变量一直存在,那么内部函数就一直存在,..

这里讲似乎不太清楚,实际情况是,外部函数的那个作用域是一直存在的,里面变量是一直保存着的;

如果重新调用外部函数,就会重新创建一片内存(作用域)来作为运行时的环境;

如果还是处于同一次调用外部函数里面,外部函数里面的变量以及各种操作都会被保留,你可以随时用内部函数去访问或修改,此时情况就像创建了类似全局对象的作用域,不会被清除掉;

&apos;&apos;直到最后一个变量废弃&apos;&apos;就是手动修改这个变量为 a=null,大概就可以清除了

最后写了一段代码,看起来有点意思,就单独拿进来.

function outerFn() {
        var outerVar = 0;
        document.write(&quot;Outer function&lt;br/&gt;&quot;);
        function innerFn1() {
            outerVar++;
            document.write(&quot;Inner function 1\t&quot;);
            document.write(&quot;outerVar = &quot; + outerVar + &quot;&lt;br/&gt;&quot;);
        }

        function innerFn2() {
            outerVar += 2;
            document.write(&quot;Inner function 2\t&quot;);
            document.write(&quot;outerVar = &quot; + outerVar + &quot;&lt;br/&gt;&quot;);
        }
        return { &quot;fn1&quot;: innerFn1, &quot;fn2&quot;: innerFn2 };
    }
    var fnRef = outerFn();
    fnRef.fn1();
    fnRef.fn2();
    fnRef.fn1();
   var fnRef2 = outerFn();    //在这里用new来创建,似乎还是一样的,说明new只是针对this来用的,对于普通的return型创建对象,效果一样,他们的作用环境还是一样,那么意味着,这种方式创建的对象都是闭包?只是如果目的是创建对象,那么一般不会在函数里面声明数据来操作.只是操作参数.
    fnRef2.fn1();
    fnRef2.fn2();
    fnRef2.fn1();
</code></pre><p>innerFn1和innerFn2引用了同一个局部变量，因此他们共享一个封闭环境。当innerFn1为outerVar递增一时，久违innerFn2设置了outerVar的新的起点值，反之亦然。我们也看到对outerFn的后续调用还会创建这些闭包的新实例，同时也会创建新的封闭环境，本质上是创建了一个新对象，自由变量就是这个对象的实例变量，而闭包就是这个对象的实例方法，而且这些变量也是私有的，因为不能在封装它们的作用域外部直接引用这些变量，从而确保了了面向对象数据的专有性。     </p>
<p>自由变量就是这个对象的实例变量,查了一下, 自由变量就是普通变量,var outerVar = 0这个;</p>
<p>在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。–百度百科</p>
<p>那么可以用一个例子来解释</p>
<pre><code>var a =0;
        function  test(){
            a++;
            this.fuck = a;
        }
        var b = new test();
        var c = new test();
        var d = new test();
        console.log(b);  //1
            console.log(c) ;//2
                console.log(d)//3;
</code></pre><p>上面的a,大概就是指实例变量,在上一个例子里面是指outervar,</p>
<p>‘’而闭包就是这个对象的实例方法’’ 大概是指,这个内部函数变成对象的实例方法了.</p>
<p>在var fnRef2 = outerFn();  这一步重新开辟新内存来运行函数,里面一个对象被接收,每次调用,这都是一个新对象,环境也是新的.</p>
<p><a href="http://www.cnblogs.com/walter-white/p/4981151.html" target="_blank" rel="noopener">http://www.cnblogs.com/walter-white/p/4981151.html</a>  //再看的话其实这个文章很经典.2017.11.15</p>
<p><a href="http://www.cnblogs.com/mrsunny/archive/2011/11/03/2233978.html" target="_blank" rel="noopener">http://www.cnblogs.com/mrsunny/archive/2011/11/03/2233978.html</a></p>
<p>主要看下后面这篇文章吧,前面是参考后面的.</p>
<p>[[scope]]属性：javascript中每个函数都是一个函数对象（函数实例），既然是对象，就有相关的属性和方法。[[scope]]就是每个函数对象都具有的一个仅供javascript引擎内部使用的属性，该属性是一个集合（类似于链表结构），集合中保存了该函数在被创建时的作用域中的所有对象，而这个作用域集合形成的链表则被称为ScopeChain（作用域链）。</p>
<p>这个例子就是如此,作用域链中保存的全局对象,里面的像键值对一样的东西,就是函数可以访问的东西,就是说,函数在创建时候,这些可以访问的已经给它提供了. </p>
<p>感觉文章里面都是干货,还是直接自己去看吧</p>
<p>性能问题：</p>
<p>在作用域链和闭包中的性能问题主要表现在数据读写的速度上。</p>
<p>由于作用域链的原因，我们访问全局作用域的数据（这里为什么不说变量呢？因为不仅包括变量，还有函数，对象等其他内容）时，效率是最低的，而访问局部数据时的效率是最高的。</p>
<p>所以一个非常经典的解决数据访问性能问题的方案出现了：将需要访问的数据尽量的以局部数据的方式缓存起来。这样当标识符解析程序在作用域链中寻找数据时，直接就可以在作用域链的最上层找到想要的数据，效率自然就提升了。</p>
<p>这句话可以解决很多性能问题：设置缓存，将数据保存在局部变量中。</p>
<p>//时隔一段时间,再看一下这些例子又有了新的理解,现在大概自己梳理一下. 2017.11.15</p>
<p>高三是这么说的</p>
<p>执行环境（execution context，为简单起见，有时也称为“环境”）是 JavaScript 中最为重要的一个概</p>
<p>念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个</p>
<p>与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们</p>
<p>编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。注意,是对象保存了可执行数据  </p>
<p>全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同大概是说框架    ，表示执行环</p>
<p>境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象（第 7 章将详细讨论），因</p>
<p>此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完</p>
<p>毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退</p>
<p>出——例如关闭网页或浏览器——时才会被销毁）。</p>
<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。</p>
<p>而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流</p>
<p>正是由这个方便的机制控制着。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是</p>
<p>保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所</p>
<p>在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对</p>
<p>象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中</p>
<p>的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延</p>
<p>续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。–高三73页</p>
<p>js里面的闭包和函数,作用域,作用域链,执行期上下文有关.</p>
<ol>
<li>函数创建的时候会添加一个作用域的属性,这个属性由浏览器内核读取,取决函数创建的位置.如果是全局里创建则它就是全局作用域,如果在局部创建则会包含这个局部作用域,当然也局部外面一层层直到全局作用域.如果有多个作用域,则会形成作用域链.这些数据都保存在一个对象当中,而这个对象里的数据,可以被重复更改 </li>
<li>函数执行的时候,会在作用域链的顶端添加一个执行期上下文的环境,它会先复制函数创建时候所创建的那个作用域链属性,自己创建一个活动对象(activetation Object),插入作用域链最顶端,它里面记录函数运行时候的形参实参以及定义的局部变量.当从上到下执行时候,遇到变量则会先从活动对象开始,然后一层一层往外面找.</li>
<li>而闭包,是外层函数在执行的时候被创建的.它在创建的时候也要执行第1个步骤,就是说自己的位置先创建一个作用域链.此时父函数还在执行阶段,它的执行期上下文就就顺理成章成了闭包函数的作用域链(创建时上下文),然后添加自己的活动对象上下文.</li>
<li>第3点的父函数执行期上下文成了闭包函数的作用域链,至于是复制了上下文,然后销毁父函数的执行期上下文,还是保存了函数的执行期上下文,然后直接引用,我也不清楚,不过效果大概一样,对内存占用是一样的,但个人偏向第一个说法,因为更好理解一些,看高三里面大概是第二个意思,如果是对象,那么引用就好了,大概不用重新复制 ,</li>
<li>如果是第一种,那么父函数执行完毕它的生命周期同样走完了,只是闭包函数里面包含了复制的作用域链.那么只要执行它就是在自己身上操作数据罢了;如果是第二种,则是在自己身上的scopechain属性上引用了环境对象,好了好了,肯定是第二种了. </li>
<li>函数是对象,身上的属性是执行期上下文,已经scopechain等属性,这些属性决定了函数执行时候可以操作的数据,引用类型的操作数据,所有函数的全局对象都是同一个,所以所有函数可以操作全局作用域的变量,重复一遍,属性指向对象,对象记录可以操作的数据<br>如果是全局对象,那么一开始就是被创建了,而它没有第一步,只有执行的时候的执行期上下文.</li>
<li>闭包的出现在于return这个操作,如果没有return,那么父函数执行后,子函数的引用也会被回收,而一旦return了,则会暴露出来,便可以通过在外层声明变量来接收这个函数对象,因为全局对象不会消失,而它自身一个属性,既一个变量,实现了对这个闭包函数的引用.</li>
<li>是return就实现了闭包吗,如果没有声明变量来接收它呢?我想return的时候就已经在栈里面创建了这个对象(它引用着前辈对象的作用环境),就是像凭空写个字面量数组,如果没有声明变量接收,它也在内存中存在了.<br>所以呢,如果没变量接收它,它会一直等着吗,凭空占据着空间,而不会产生任何作用,除了占空间?那么,它只是在内存中待着了?一些二进制的数据表明它已经存在,但是没有任何线和这个数据连通的是吧.<br>后来理解到,如果没有引用,它就会被回收掉,所以如果没有变量引用它,它不会一直等着,只要把指针=null就好了   </li>
<li><p>再重复一遍,万物皆对象.</p>
<pre><code>语言设计的时候就是如此.设计成各种对象的引用,基本数据类型就是一串简单的数据,而复杂数据类型就是一个数据集合,由一块完整的内存空间来保存.而代码则是在内存中创建这些空间,并且操作内存空间中的数据的过程.
这些对象相互引用,通过变量,或者说是对象的属性,有些属性用户可以读取,而基本类型的数据,比如在全局变量声明一个var a = 1,这个就没法在window对象上面看到了,大概也是因为如果能看到的话就太多数据了.
代码对这些数据的操作,会返回各种数据,而浏览器内核对数据的解析,则形成了各种图案,各种表现形式,各种交互规则.
</code></pre></li>
<li><p>回过头来谈谈作用域和性能之类的.<br>执行期上下文,它也是一个作用域对象,里面东西是动态改变的,一开始只有参数(全局变量没有),然后再进行对对应属性的操作,声明变量则是创建属性,赋值则是对属性赋值,声明函数则是创建方法(对象),return也是方法,表示函数对象执行完毕后被接收的值<br>作用域只是变量的一个属性,而多层嵌套函数,它会形成多层嵌套的作用域链,代码在执行的时候,先是查找,读取到变量的指针(指向数据),它便会return,要注意的是,它大概 不需要遍历当前作用域对象的所有属性,因为遍历之前,它的属性会被覆盖,是唯一的,同时,代码每执行一次,都会操作(包括改变)对应的作用域对象 ;<br>大概类似  for (var key in 作用域对象 ) { if (key ==变量名){ 变量名的值 等于 作用域对象[key] } };<br>而要修改或者说操作值的时候,那也是先找到,然后进入作用域对象里面去修改这个对应的属性值.<br>(在高三中,有一节的说法是查找标识符)<br>代码执行,就是查找,和操作作用域对象相应属性的过程.<br>局部作用域因为不需要找那么多,当然性能要好一些了.<br>当函数对自己或者父辈作用域的属性操作完成之后,这个局部作用域对象会被回收掉,就是说,上级作用域对象的对它的引用,会被清空,设置为null,没了对它的引用,它只是存在于内存中一下子,会被当做垃圾回收掉吧.</p>
</li>
<li>当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”.<br>闭包的原理就是这个闭包函数被带到了全局环境(外层环境),只要你没关闭浏览器,就一直在全局环境中,就永远不会释放内存.<br>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉(环境中的变量 以及被环境中的变量 引用的变量 )的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 –高三79页<br>可以推测,即使闭包函数被父函数return出来了,如果没有外层环境的变量来对它进行引用,那么闭包函数会被当做垃圾清除.<br>从逻辑上来看,父函数执行一次并且提供闭包函数的返回,只是在操控了父函数对象一次,并且提供一个返回值,<br>如果没人要这个返回值,没理由不回收这个内存.如果没回收,那肯定是设计有问题.<br>ECMAScript 拥有无用存储单元收集程序（garbage collection routine），意味着不必专门销毁对象来释放内存。当再没有对对象的引用时，称该对象被废除（dereference）了。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些其他不可预知的情况下，无用存储单元收集程序也会运行。–w3c对象应用那一页<br>不可预知情况下指的是将引用设置为null,没有了引用的对象,在下一次垃圾清除时会被回收.设置为null被认为是一种好方法,因为旧版浏览器没有这个机制.而要注意的是,如果有多个变量引用到同一对象,那么需要将所有引用都废除才行.</li>
<li>闭包长得像函数，但是闭包不是函数。闭包可以访问函数之外的环境，这不是简单的函数可以做到的。按照这里的定义，闭包更应该是函数与定义函数的环境所组成的实体。可以将闭包与面向对象的对象类比，定义闭包函数的环境(父函数的参数与变量)是属性，闭包函数的方法。闭包是比较特殊的对象，主要是：闭包的生命周期比较特殊，创建闭包的父函数执行完毕，闭包仍然可以存在；对象的核心是数据，而闭包的核心是函数。对象是附有方法的数据，闭包是附有数据的方法。  –前面链接的一段话<br>这段话也比较经典,闭包和环境组成的实体,环境本来就是个对象,而闭包函数可以操作这个对象,当然不太方便了.</li>
<li>再谈谈万物皆对象和this的联系.this,大概是每个对象都有的一个属性,而这个东西引用的就是它自己的对象,就是说它属于哪个对象的属性,就是引用到哪里.这个引用也可以被其他变量接收.</li>
<li>稍微总结一下,打开浏览器,引擎执行代码</li>
<li>预解析的过程等于声明创建了对象的属性(方法),而执行过程对这些属性和方法进行操作.</li>
</ol>
<p>访问一个对象上面未定义的属性,那是undefined值.</p>
<pre><code>//给对象的属性赋值就像在外面声明变量一样的吗.
   var  obj = {};
   console.log(obj.name);  //这一步的操作等于 在window里面声明一个 name 变量是吧. 然后再直接赋值
   var arr = [];
   console.log(arr[12]);
   //var a =&apos;1&apos; ;  //有意思的事情, var a 的意思是在window里面添加一个a属性,但是是预解析就添加了, 之后再赋值,这就是提升作用.
   // 而window.a 只是一个赋值动作的一半,如果不加个等于 数字, 意思就是全局上空写了个a,而这a是会被报错的没定义.
   //就像,如果不用 var 来提升,直接用 a =1 ,就是执行阶段才创建a,并且赋值.
   window.a; //如果这样子写,并不会在window对象里面创建一个a对象,他是会被报错的未定义.只有赋值时候才会被创建
   if (window.a===undefined) {    //
     console.log(&apos;tell me truth&apos;);
   }
   console.log(a); //再打印的话会报错的未定义
   console.dir(window);
   console.log(window.a); //如果只有打印window.a的话,就是已经未定义的,他已经有了一个值, 
   //反正对window里面未定义的属性,如果判断属性值是否是undifined,是会报错的,如果用window.属性来判断,可以可以有一个值.
</code></pre><p>经典面试题,包括预解析,原型,new,调用等知识</p>
<pre><code>//        要先预解析
        function Foo(){
            getName = function(){ console.log(1); };
          console.log(this);   //当这个函数被被window执行的时候, this指向window
          return this;   //当这个函数被new出来的空对象接收的时候,它指向了空对象
        }             //所以,构造函数的方式是,创建一个新对象,this.属性/方法 可以添加方法, 也可以return this, 也是可以这样的
        Foo.getName = function(){ console.log(2); };
        Foo.prototype.getName = function(){ console.log(3); };
        var getName = function(){ console.log(4); };  //这一步是赋值了.
        function getName(){ console.log(5); }
//        new  和最近的函数调相结合
        Foo.getName();   //2
        getName();        //4
        Foo().getName();     //1   //当foo执行的时候,把全局的getName给改掉了,然后再调用全局的getName
//        这个是返回window,window的getname已经被改了
        getName();              //1  //这getName已经是被该了之后的.
console.log(new Foo());  //返回了一个空的对象,
new Foo.getName();      //2   //foo的静态方法 //这个new没有生效,因为Foo并没有调用
        new Foo().getName();      //3   //new的方法,创建一个对象,一个新的实例对象实例,而是new的一个对象
// 这个对象的原型里面的方法才是他才可以调用.
        new new Foo().getName();   //3  //new在前面失效了, 不管放几个new都一样的
</code></pre><p>当浏览器敲网址的时候,这一瞬间发生了什么事情?</p>
<p>1通过DNS服务器找IP地址,2对应的IP地址找到对应服务器, 3传回来数据,然后浏览器给渲染.</p>
<p>面向对象和面向过程的区别?</p>
<p>自己去看笔记.(虽然这个就是笔记)</p>
<p>面向对象有两个好处:</p>
<p>1 是写了方法之后可以直接调用,适合多人方式来做,2 ,每个方法有依赖的对象之后,维护性可以提高了,只要找到出错的对象就可以了</p>
<p>第一个好处,等于是知道所有的功能,不用知道里面到底具体是怎么做的.</p>
<p>第二个好处,等于是整理信息,然后调用的时候就方便,而不依赖对象的话,就等于图书馆的书没有分类直接放到书架上.</p>
<p>创建对象的方式以及各种的区别?</p>
<p>构造函数用的时候要用大写,工厂函数是简单函数,用小写开头.</p>
<p>构造函数的默认模式.</p>
<pre><code>会在内存中创建一个空对象   //而用创建空对象的工厂函数,是手动 new一个空对象
设置构造函数的this，让this指向刚刚创建好的对象 //工厂函数用空对象然后设置属性来做
执行构造函数中的代码 //
返回对象//工厂函数最后还要手动return的创建的新对象
</code></pre><p>都是构造函数产生的,只是我们说的构造函数是自定义构造函数,其他方式是用Object创建对象的函数来创建 </p>
<p>构造函数的对象有constructor属性,但是这个属性可以被改变,一般用instanceof来判断是否是某个对象的实例.</p>
<p>静态成员和实例成员的区别?</p>
<p>这两个东西根本不是一类.静态成员是构造函数这个对象的一个属性;实例成员是构造函数生成的实例.</p>
<p>构造函数的静态成员不能被实例成员直接调用,还是要用构造函数名.属性 这样子来访问.</p>
<p>如果在添加属性的时候加上一个prototype那就没问题了.</p>
<p>prototype就是一个对象,当生成实例时候,会直接继承原型里面的属性和方法.</p>
<p>这意味着什么? 构造函数本身也是一个对象的方法,这个对象就是window,  </p>
<p>如果一个对象的 原型里面的属性和自身属性冲突?获取什么?</p>
<p>,比如自身名字属性是由参数控制,而原型属性是固定的,那么的出来的值,到时候会获得自身属性.</p>
<p>意思是自身属性找不到了会去原型属性上去找.</p>
<pre><code>s1.__proto__  对象的__proto__ 等于  构造函数的Student.prototype, 
//实例的_proto_就是完全引用构造函数的原型.
 //不过__proto__有兼容性问题,如果可以的话尽量用entity.constructer.prototype
</code></pre><p>构造函数   原型对象  实例  三者关系?</p>
<p>我们平时所说的构造函数严格来说,要叫自定义构造函数,因为就算是字面量或者函数,那也是由Object函数来做的.</p>
<pre><code> //构造函数拥有原型对象, 原型对象是构造函数的一个属性,这个属性指向一个原型对象,刚创建出来的时候,原型对象只有一个constructer属性,没有别的属性,等于一个空对象,之后可以再添加.添加之后这个对象的属性和方法被实例所继承
//原型对象也会有一个constructer属性,同时又指回构造函数本身
//而实例继承了原型对象的属性和方法,__proto__指向了构造函数的原型对象.
</code></pre><p>对象文件查找规则是什么?</p>
<pre><code>读取属性  先在对象本身查找test属性，如果没有找到的话，会去原型链上查找
// test属性在原型对象上，而在设置属性的值的时候，不会搜索原型链
// 而是直接给对象新增一个test属性
</code></pre><p>对本地对象添加属性的时候应该不能覆盖吧? 可以单独修改内置方法</p>
<p>不能,JS本地对象的原型不能整体覆盖，只能单独地动态地为原型添加属性或方法</p>
<p>比如不能用 Array.prototype= {(某个对象)},如果直接这样子该的话不能改了,就算在对象里面设置constructer属性为 Array,还是不能修改</p>
<p>只能Array.prototype.方法或属性 =  函数 . 如果单独修改或者覆盖内置方法的话是可以的. </p>
<p>bind,call,apply三者的区别?</p>
<p>总结：call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。</p>
<p>bind方法是返回一个新的函数,还要用一个变量来接收这个函数才行.</p>
<p>它们可以传进去参数,不同的是apply的参数必须是一个数组,对应原函数的arguments数组.而call可以直接用.</p>
<p>至于bind,他传进去参数和call的形式一样. </p>
<p>确实不错, bind的后面添加的对象来指定环境,但是没有调用.</p>
<p>这些方法如果只是借助别人的方法, 比如 math.max.apply,如果不涉及指定对象的操作,那么第一个参数随便是什么都可以, 一般null,</p>
<p>math.max.apply(null,array.map(function(){})),这样子很有用,数组的map方法就是返回一个数组.</p>
<p>AJAX相关东西</p>
<p>参数的东西</p>
<p>如果是get准备阶段,输入的URL地址参数里面用问号,然后参数名=来获取,</p>
<p>但如果不需要参数,那?问号后面跟着任何东西都可以,所以,它的逻辑大概是参数只是用来过滤返回的值,如果参数类型不对,没法过滤,则返回的还是无参数的形式.</p>
<p>同样的如果是post,xhr.send()里面的东西也是随便填的,只要是字符串就好,反正过滤不了的话就会返回所有的东西.</p>
<p>不管是不是get,如果说明不需要参数,那返回的则是整个php文件所生成的数据,可以是json_encode所生成是字符串.也可以是完整的XML数据,result就是这个样子</p>
<p>模板引擎 插件</p>
<p>字符串拼接的缺点在于:量大了不方便,而且里面也没有结构层次,看起来不方便,总之就是使用不方便,维护也不方便.</p>
<p>那么使用模板引擎, 下面一些要注意的 </p>
<p>这里是简洁版的语法</p>
<pre><code>得到数据中的值{{value}}
循环操作{{each result as value i }}{{/each}} ;   //后面的as value i可以不写,在后面可以用index 和 value获取
转义：#的使用{{#value}}
条件判断{{if xxx}}{{/if}}
导入子模板  {{include 'list'}}   //&lt;!-- 下文的list模板,就是说,封装一个模板,将其导入,后面还可以加一个参数,新数据 --&gt;  {{include 'template_name' news_list}}
技巧：有时候有可能需要对原始数据进行加工操作 //就是不能直接处理对象,只能处理对象的一个属性
&lt;!--  如果直接传入数组,是否不需要s ,答案是需要重新包装一下,将其变成另外一个对象的属性--&gt;
&lt;!-- 不需要data.s这样来做,就像window里面的变量不需要window.a,这是作用域的关系 --&gt;
&lt;!-- 空格也只有一个就行了,多了可能会报错 --&gt;
&lt;!-- {{}}这是另外一种语法了,包裹起来的可以用each的方式来遍历,应该也有别的方式来处理,不是遍历的 --&gt; //貌似没说别的,就是遍历了,可以带形参,也可以不带,
&lt;!-- as value i ,一个是值,一个是属性,不过这个是等于形参,value和i可以变化--&gt;
&lt;!-- 这里遍历的是数组,实际上可以遍历对象 --&gt;
&lt;!-- 双大括号外边的东西不做特殊处理 --&gt;
&lt;!-- 下文的template方法第一参数是id选择器,第二个参数是数据源,可以查看一下别的参数 --&gt;
&lt;!-- 从后面的例子来看, {{}}里面可以直接写属性名,等于是变量,返回属性值 --&gt;
&lt;!-- 还有转义不转义的区别,默认是不转义的,就是打印字符串,如果转义,需要加上#号,会被当做标签来处理 --&gt;
&lt;!-- 下文的list模板,就是说,封装一个模板,将其导入,后面还可以加一个参数,新数据 --&gt;
</code></pre><p>BOM</p>
<p>BOM 的核心对象是 window ，它表示浏览器的一个实例。在浏览器中， window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问parseInt() 等方法。</p>
<p>非常有意思.</p>
<p>定义的全局变量(var xxx)的形式,会成为window对象的属性,但是和 window.xxx=的形式还是有点区别.delete操作符可以删除后者.而前者不行.另外,如果直接访问未声明的变量,会报错,而访问window.xxx这样的话,会访问undefined,因为这是属性查询 .这个属性查询是原文,说明引擎获取属性的方式是循环遍历 .</p>

    </div>
    <footer>
        
        
		<div class="bdsharebuttonbox">
	<a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
	<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_count" data-cmd="count"></a>
</div>
<script>
window._bd_share_config=
{
	"common":{
		"bdSnsKey":{},
		"bdText":"",
		"bdMini":"2",
		"bdMiniList":false,
		"bdPic":"",
		"bdStyle":"0",
		"bdSize":"24"
	},
	"share":{},
	"image":{
		"viewList":["qzone","tsina","tqq","renren","weixin","fbook","twi"],
		"viewText":"分享到：",
		"viewSize":"24"
	},
	"selectShare":{
		"bdContainerClass":null,
		"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin","fbook","twi"]
	}
};
with(document)0[
	(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)
];
</script>    
        <div class="clearfix"></div>
    </footer>
  </div>
</article>

 <nav id="pagination" >
    
    
    <a href="/2018/01/18/Ajax/" class="alignright next" title="Ajax">Ajax</a>
    
    <div class="clearfix"></div>
</nav>



	
	<section id="comment">
		<!-- 多说评论框 start -->
		<div class="ds-thread" data-thread-key="2018/01/18/js动画笔记/" data-title="JS动画笔记" data-url="http://yoursite.com/2018/01/18/js动画笔记/"></div>
		<!-- 多说评论框 end -->
		<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
		<script type="text/javascript">
		var duoshuoQuery = {short_name:""};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
			 || document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
		</script>
		<!-- 多说公共JS代码 end -->
	</section>
	
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  

  <iframe width="100%" height="140" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1923610190&verifier=6af5ad6a&colors=fafafa,fafafa,666666,0082cb,ecfbfd&dpc=1"></iframe>

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://opiece.me" title="Chillax's Blog" target="_blank">Chillax</a></li>
</ul>
</div>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer"><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hi,I&#39;m the designer of this theme. <br/>
			You can download this theme on my github.</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/1923610190" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/huangjunhui" target="_blank" title="github"></a>
		
		
		<a href="https://www.facebook.com/huangjunhui" target="_blank" title="facebook"></a>
		
		
		
		<a href="mailto:jhhuang1993@foxmail.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/huangjunhui/concise" target="_blank" title="Concise">Concise</a> © 2018 
		
		<a href="http://yoursite.com/about" target="_blank" title="Yi Zhou">Yi Zhou</a>
		
		</p>
</div>
</footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/counter.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<div id="totop" style="position:fixed;bottom:100px;right:10px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


